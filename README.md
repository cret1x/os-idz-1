# ИДЗ №1
## Амирханов Никита БПИ219
## Вариант 18
Разработать программу, заменяющую все согласные буквы в заданной ASCII-строке на заглавные.

### Запуск кода
В заданиях на оценку 4-7: `gcc main.c -o main` и `./main <input> <output>`. Для заданий 8-9: `gcc proc1.c -o proc1` `gcc proc2.c -o proc2`. Затем запуск полученных програм в любом порядке.

### Тестирование
Все тесты, а так же резульатты запуска лежат в папке `/tests`
Тест 1: Тест строки меньше 128 байт
Тест 2: Тест строки размером 500 байт
Тест 3: Тест строки без согласных
Тест 4: Тест строки с заглавными согласными
Тест 5: Очень большой текст

### 4
Имеется приложение, которое с помощию функции `fork()` создает дочерние процессы. Первый процесс через первый неименнованный канал отправляет данные второму. Второй их обрабатывает и через второй неименнованный канал отправляет третьему процессу. Третий процесс выводит результат в файл. Синхронизация производится за счет блокировки процесса методом `read()`.
### 5
Имеется приложение, которое с помощию функции `fork()` создает дочерние процессы. Первый процесс через первый именнованный канал `char* pipe_read_calc = "prc.fifo"` отправляет данные второму. Второй их обрабатывает и через второй именнованный канал `char* pipe_calc_write = "pcw.fifo` отправляет третьему процессу. Третий процесс выводит результат в файл.  Синхронизация производится за счет блокировки процесса методом `read()`.
### 6
Имеется приложение, которое с помощию функции `fork()` создает дочерние процессы. Первый процесс через первый неименнованный канал отправляет данные второму. Второй их обрабатывает и через второй неименнованный канал отправляет назад перврому процессу, который выводит результат в файл.  Синхронизация производится за счет блокировки процесса методом `read()`.
### 7
Имеется приложение, которое с помощию функции `fork()` создает дочерние процессы. Первый процесс через первый именнованный канал `char* pipe_read_calc = "prc.fifo"` отправляет данные второму. Второй их обрабатывает и через второй именнованный канал `char* pipe_calc_write = "pcw.fifo` отправляет назад первому процессу, который выводит результат в файл.  Синхронизация производится за счет блокировки процесса методом `read()`.
### 8
Есть две программы. Подрядок запуска не важен. Принцип работы такой же как и в задании на 7 баллов.
### 9
Так же имеется две программы, но размер буффера ограничен 200 байтами. Чтение происходит порциями, которые сразу отправляются в второй процесс, где обрабатываются и возвращаюся в первый, после чего сразу пишутся в выходной файл.
### 10
Работа схожа с заданием на 9 баллов, но вместо именнованных каналов используется очередь сообщений. Первый процесс читает из файла и передает данные в первую очередь, второй процесс читает из нее пока в ней есть сообщения, после чего отправляет обработанные результаты через вторую очередь в первый процесс. Первый процесс так же читает из очереди пока в ней есть сообщения и пишет все в файл.